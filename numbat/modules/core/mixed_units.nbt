use core::strings
use core::lists
use core::numbers
use core::quantities

# Helper functions for mixed-unit conversions. See units::mixed for more.

fn _zero_length<A: Dim>(val: A) -> A = val * 0 -> val

fn _mixed_unit_list<D: Dim>(val: D, units: List<D>, acc: List<D>) -> List<D> =
  if val == 0
    then concat(acc, map(_zero_length, units))
    else if len(units) == 1
      then cons_end(val -> head(units), acc)
      else _mixed_unit_list(val - unit_val, tail(units), cons_end(unit_val, acc))
  where unit_val: D =
    if (len(units) > 0)
      then (val |> trunc_in(head(units)))
      else error("Units list cannot be empty")
  

fn _clean_units<D: Dim>(units: List<D>) -> List<D> = units |> unique() |> sort() |> reverse()

fn _unit_list<D: Dim>(units: List<D>, value: D) -> List<D> = _mixed_unit_list(value, _clean_units(units), [])

@description("Round a mixed unit number to the nearest multiple of `base`.")
@example("[0 days, 12 hours, 0 minutes, 30 seconds] |> round_mixed_in(minutes)")
@example("[0 days, 12 hours, 29 minutes, 30 seconds] |> round_mixed_in(hours)")
fn round_mixed_in<D: Dim>(base: D, value: List<D>) -> List<D> = value |> sum |> round_in(base) |> _unit_list(units)
  where units = value |> filter(is_not_zero) |> map(unit_of) |> cons(base)